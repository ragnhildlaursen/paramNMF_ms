#library("magic")
load("BRCA/BRCA21.RData")
wd()
#library("magic")
load("BRCA/BRCA21.RData")
#library("magic")
load("BRCA21.RData")
setwd("~/projects/Parametrization")
#library("magic")
load("BRCA/BRCA21.RData")
load("BRCA/BRCA21.RData")
#source("U:/Projects/DinucleotideSignatures/ModelSelectCode/ModelSelectCode/modelselection.R")
##------------------------------------------------------------
## BRCA21 data analysis with number of signatures equal to four
##------------------------------------------------------------
## We consider 15 models with the three signatures
## Mono-nucleotide (Shiraishi et al),
## Di-nucleotide (our proposed signature),
## Tri-nucleotide (Alexandrov et al)
## Run each model 30 times with different initializations
##------------------------------------------------------------
source("GitModelSelection.R")
load("BRCA/BRCA21.RData")
View(V)
L = factor(substr(rownames(V), start = 1, stop = 2))
L = factor(substr(rownames(V), start = 1, stop = 1))
M = factor(substr(rownames(V), start = 3, stop = 5))
R = factor(substr(rownames(V), start = 7, stop = 7))
##--------------------------------------------------------
## Factors
##--------------------------------------------------------
## The factors for 96 different mutation types
L = factor(substr(rownames(V), start = 1, stop = 1))
M = factor(substr(rownames(V), start = 3, stop = 5))
R = factor(substr(rownames(V), start = 7, stop = 7))
##--------------------------------------------------------
## Parametrizations of a signature
##--------------------------------------------------------
## Model matrices
Mfull = model.matrix(~0+L*M*R)      # full model
Mdi = model.matrix(~0+L*M + M*R)    # di-nucleotide model
Mmono = model.matrix(~0+L + M + R)  # multiplicative model
models = list(Mmono,Mdi,Mfull)      # list of 3 models
## List of 15 models for the 3 parametrizations with 4 signatures
nmbrSignatures=4
ModelCombinations = combinations(length(models), nmbrSignatures,
repeats.allowed = TRUE)
ModelCombinations
MList = lapply(1:nModels,lapply(ModelCombinations[1,], function(y) models[[y]]))
MList = lapply(1:nModels,function(x) lapply(ModelCombinations[x,], function(y) models[[y]]))
nModels <- nrow(ModelCombinations)
MList = lapply(1:nModels,function(x) lapply(ModelCombinations[x,], function(y) models[[y]]))
View(MList)
nModels <- nrow(ModelCombinations)
MList = lapply(1:nModels,function(x) lapply(ModelCombinations[x,], function(y) models[[y]]))
##-----------------------------------------------------------
## Matrix with summary of the results
##-----------------------------------------------------------
resMat <- matrix(0,nrow=nModels,ncol=7)
colnames(resMat) <- c("nprm1","nprm2","nprm3","nprm4","nprmtot","seed","GKL")
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList,
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList,
tolerance=low.tolerance,Seeds=jmin)$gkl
##
resMat[m,7] <- res
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList,
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)$gkl
##
resMat[m,7] <- res
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)$gkl
##
resMat[m,7] <- res
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
##------------------------------------------------------------
## BRCA21 data analysis with number of signatures equal to four
##------------------------------------------------------------
## We consider 15 models with the three signatures
## Mono-nucleotide (Shiraishi et al),
## Di-nucleotide (our proposed signature),
## Tri-nucleotide (Alexandrov et al)
## Run each model 30 times with different initializations
##------------------------------------------------------------
source("GitModelSelection.R")
# load BRCA data
load("BRCA/BRCA21.RData")
##--------------------------------------------------------
## Factors
##--------------------------------------------------------
## The factors for 96 different mutation types
L = factor(substr(rownames(V), start = 1, stop = 1))
M = factor(substr(rownames(V), start = 3, stop = 5))
R = factor(substr(rownames(V), start = 7, stop = 7))
##--------------------------------------------------------
## Parametrizations of a signature
##--------------------------------------------------------
## Model matrices
Mfull = model.matrix(~0+L*M*R)      # full model
Mdi = model.matrix(~0+L*M + M*R)    # di-nucleotide model
Mmono = model.matrix(~0+L + M + R)  # multiplicative model
models = list(Mmono,Mdi,Mfull)      # list of 3 models
## List of 15 models for the 3 parametrizations with 4 signatures
noSignatures=4
ModelCombinations = combinations(length(models), noSignatures,
repeats.allowed = TRUE)
nModels <- nrow(ModelCombinations)
MList = lapply(1:nModels,function(x) lapply(ModelCombinations[x,], function(y) models[[y]]))
##-----------------------------------------------------------
## Matrix with summary of the results
##-----------------------------------------------------------
resMat <- matrix(0,nrow=nModels,ncol=7)
colnames(resMat) <- c("nprm1","nprm2","nprm3","nprm4","nprmtot","seed","GKL")
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)$gkl
## print results
resMat[m,7] <- res
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
resFactors = list()
##-----------------------------------------------------------
## Matrix with summary of the results
##-----------------------------------------------------------
resMat <- matrix(0,nrow=nModels,ncol=7)
colnames(resMat) <- c("nprm1","nprm2","nprm3","nprm4","nprmtot","seed","GKL")
resFactors = list()
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
resFactors[[m]] <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)
## print results
resMat[m,7] <- res$gkl
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
##-----------------------------------------------------------
## Matrix with summary of the results
##-----------------------------------------------------------
resMat <- matrix(0,nrow=nModels,ncol=7)
colnames(resMat) <- c("nprm1","nprm2","nprm3","nprm4","nprmtot","seed","GKL")
resFactors = list()
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)
resFactors[[m]] = res
## print results
resMat[m,7] <- res$gkl
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res,"\n" )
}
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)
resFactors[[m]] = res
## print results
resMat[m,7] <- res$gkl
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res$gkl,"\n" )
}
##------------------------------------------------------------
## BRCA21 data analysis with number of signatures equal to four
##------------------------------------------------------------
## We consider 15 models with the three signatures
## Mono-nucleotide (Shiraishi et al),
## Di-nucleotide (our proposed signature),
## Tri-nucleotide (Alexandrov et al)
## Run each model 30 times with different initializations
##------------------------------------------------------------
source("GitModelSelection.R")
# load BRCA data
load("BRCA/BRCA21.RData")
##--------------------------------------------------------
## Factors
##--------------------------------------------------------
## The factors for 96 different mutation types
L = factor(substr(rownames(V), start = 1, stop = 1))
M = factor(substr(rownames(V), start = 3, stop = 5))
R = factor(substr(rownames(V), start = 7, stop = 7))
##--------------------------------------------------------
## Parametrizations of a signature
##--------------------------------------------------------
## Model matrices
Mfull = model.matrix(~0+L*M*R)      # full model
Mdi = model.matrix(~0+L*M + M*R)    # di-nucleotide model
Mmono = model.matrix(~0+L + M + R)  # multiplicative model
models = list(Mmono,Mdi,Mfull)      # list of 3 models
## List of 15 models for the 3 parametrizations with 4 signatures
noSignatures=4
ModelCombinations = combinations(length(models), noSignatures,
repeats.allowed = TRUE)
nModels <- nrow(ModelCombinations)
MList = lapply(1:nModels,function(x) lapply(ModelCombinations[x,], function(y) models[[y]]))
##-----------------------------------------------------------
## Matrix with summary of the results
##-----------------------------------------------------------
resMat <- matrix(0,nrow=nModels,ncol=7)
colnames(resMat) <- c("nprm1","nprm2","nprm3","nprm4","nprmtot","seed","GKL")
resFactors = list()
## identify global minimum
## Second run EM algorithm with seed from global minimum but
## with low tolerance (i.e. until convergence)
## Here we use high tolerance=25 and low tolerance=5
## to run the algorithm in a few minutes.
## In order to obtain the results in the paper you *must* run with
## high tolerance=1 and low tolerance=0.2
## On a normal latop this takes around 5 minutes.
## The GKL is summarized in resMat.
## We provide resMat for our run in file "GitUCUT26results.txt"
high.tolerance <- 1
low.tolerance <- 0.2
for (m in 1:nModels){
nprm1 <- ncol( MList[[m]][[1]] )
nprm2 <- ncol( MList[[m]][[2]] )
nprm3 <- ncol( MList[[m]][[3]] )
nprm4 <- ncol( MList[[m]][[4]] )
resMat[m,1] <- nprm1
resMat[m,2] <- nprm2
resMat[m,3] <- nprm3
resMat[m,4] <- nprm4
resMat[m,5] <- nprm1+nprm2+nprm3+nprm4
## List of models chosen
## Run the EM algorithm many times with a high tolerance to identify global minimum
tmp <- rep(0,30)
cat("Model:",m,"","\n")
cat("EM Run: ")
for (j in 1:length(tmp)){
cat(j,"")
tmp[j] = NMFglmSQR(Data=V, NoSignatures=4,DesignMatrix = MList[[m]],
tolerance =high.tolerance, Seeds = j)$gkl
}
## Choose the best initial value and run again until convergence, i.e.
## stop when the tolerance is small
cat("\n")
jmin <- which.min(tmp)
resMat[m,6] <- jmin
res <- NMFglmSQR(Data=V,NoSignatures=4,DesignMatrix=MList[[m]],
tolerance=low.tolerance,Seeds=jmin)
resFactors[[m]] = res
## print results
resMat[m,7] <- res$gkl
cat("Final result:","nprm:",nprm1,nprm2,nprm3,nprm4,
"; seed:",jmin,", GKL:",res$gkl,"\n" )
}
save(resFactors, file = "BRCAmodelFactors.RData")
dim(V)
